<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Our Love Story üíï</title>
  <style>
    body{
      margin:0;
      font-family:Arial, sans-serif;
      background:linear-gradient(to right,#ff758c,#ff7eb3);
      color:white;
      text-align:center;
    }
    h1{margin:18px 10px 8px;}
    h2{margin:16px 10px 8px;}

    .countdown{margin:10px 12px;font-size:16px;line-height:1.45;}

    .slideshow{
      position:relative;
      width:250px;
      height:350px;
      margin:16px auto 10px;
    }
    .slideshow img{
      position:absolute;
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:20px;
      opacity:0;
      transition:opacity 1s;
      box-shadow:0 12px 28px rgba(0,0,0,0.25);
    }
    .slideshow img.active{opacity:1;}

    button{
      padding:12px 18px;
      font-size:16px;
      margin:8px;
      border:none;
      border-radius:12px;
      cursor:pointer;
      box-shadow:0 10px 22px rgba(0,0,0,0.18);
    }
    #yesBtn{background:#ff4d6d;color:white;}
    #noBtn{background:white;color:#111;}
    #musicBtn{background:rgba(0,0,0,0.35);color:white;}

    #loveOverlay{
      position:fixed;
      inset:0;
      background:#ff4d6d;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:6vw;
      font-weight:900;
      z-index:50;
      opacity:0;
      transition:opacity 1s;
      pointer-events:none;
    }

    /* Game */
    .gameWrap{
      width:min(96vw, 920px);
      margin:14px auto 18px;
      position:relative;
    }
    canvas#game{
      width:100%;
      aspect-ratio:3/1;
      background:white;
      border-radius:16px;
      display:block;
      box-shadow:0 14px 34px rgba(0,0,0,0.25);
      border:2px solid rgba(0,0,0,0.08);
    }

    .hud{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin:10px 8px 12px;
      font-size:14px;
    }
    .pill{
      background:rgba(0,0,0,0.25);
      padding:8px 12px;
      border-radius:999px;
      backdrop-filter: blur(6px);
    }

    /* On-canvas controls */
    .pad{ position:absolute; inset:0; pointer-events:none; }
    .padBtn{
      pointer-events:auto;
      position:absolute;
      padding:12px 14px;
      border-radius:14px;
      font-weight:800;
      border:none;
      box-shadow:0 10px 22px rgba(0,0,0,0.22);
      opacity:0.92;
    }
    .padJump{left:12px; bottom:12px; background:#ff4d6d; color:white;}
    .padFwd{right:12px; bottom:12px; background:white; color:#111;}
    .padPause{top:12px; right:12px; background:rgba(0,0,0,0.45); color:white;}

    .hint{opacity:0.9;font-size:13px;margin:6px 12px 22px;}

    /* Game over overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.62);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:60;
      padding:16px;
    }
    .card{
      width:min(540px, 92vw);
      background:rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.25);
      border-radius:18px;
      padding:16px;
      box-shadow:0 18px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
    }
    .row{
      display:flex;
      gap:14px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      margin:10px 0 6px;
    }
    .pixelCard{
      background:rgba(255,255,255,0.14);
      border:1px solid rgba(255,255,255,0.22);
      border-radius:14px;
      padding:10px;
      width:190px;
    }
    .miniCanvas{
      width:140px;
      height:140px;
      display:block;
      margin:0 auto 6px;
      background:rgba(255,255,255,0.9);
      border-radius:12px;
    }
    .replay{
      width:100%;
      background:#ff4d6d;
      color:white;
      font-size:18px;
      padding:14px 16px;
      border-radius:14px;
      margin-top:10px;
    }
  </style>
</head>
<body>

  <div id="loveOverlay">I LOVE YOU ‚ù§Ô∏è</div>

  <h1>Will You Be My Valentine? üíò</h1>

  <div class="countdown">
    ‚ù§Ô∏è Countdown to February 25:
    <div id="valentineCountdown"></div>
    üíç Countdown to Our 5-Year Anniversary (Feb 25, 2027):
    <div id="anniversaryCountdown"></div>
  </div>

  <div class="slideshow">
    <img src="456C3DFA-6694-47CD-9340-C41EDA179452.jpeg" class="active">
    <img src="9779781B-6837-46AD-8A78-09F7AD151B48.jpeg">
    <img src="EE0C9E1C-9B92-4CEC-91BF-210B3D5DB6D5.jpeg">
  </div>

  <div>
    <button id="yesBtn" onclick="yesClicked()">Yes üíï</button>
    <button id="noBtn" onclick="noClicked()">No üôÑ</button>
    <button id="musicBtn" onclick="toggleMusic()">üîä Music: On</button>
  </div>

  <audio id="music" loop>
    <source src="song.mp3" type="audio/mpeg">
  </audio>

  <h2>‚ù§Ô∏è Heart Run: City Edition üåÜ</h2>

  <div class="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">High: <span id="high">0</span></div>
    <div class="pill">Speed: <span id="spd">1.0</span>x</div>
    <div class="pill">Space=Jump ‚Ä¢ Shift=Forward ‚Ä¢ P=Pause</div>
  </div>

  <div class="gameWrap">
    <canvas id="game" width="900" height="300"></canvas>
    <div class="pad">
      <button class="padBtn padPause" id="pauseBtn">‚è∏ Pause</button>
      <button class="padBtn padJump" id="jumpBtn">‚¨ÜÔ∏è Jump</button>
      <button class="padBtn padFwd" id="fwdBtn">‚û°Ô∏è Forward</button>
    </div>
  </div>

  <div class="hint">
    Tip: collect ‚ù§Ô∏è for bonus points. Obstacles have smaller hitboxes so it‚Äôs fair.
  </div>

  <div class="overlay" id="gameOver">
    <div class="card">
      <h2>Game Over üíî</h2>
      <p style="margin:6px 0 10px;">
        Your Score: <b id="finalScore">0</b> ‚Ä¢ High Score: <b id="finalHigh">0</b>
      </p>

      <div class="row">
        <div class="pixelCard">
          <canvas class="miniCanvas" id="miniHer" width="140" height="140"></canvas>
          <div><b>Her</b> üíï</div>
        </div>
        <div class="pixelCard">
          <canvas class="miniCanvas" id="miniYou" width="140" height="140"></canvas>
          <div><b>You</b> üñ§</div>
        </div>
      </div>

      <p style="margin:8px 0 0; opacity:0.95;">‚ÄúOkay‚Ä¶ run it back üò§‚ù§Ô∏è‚Äù</p>
      <button class="replay" onclick="restart()">Replay ‚ù§Ô∏è</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <script>
    /* ---------------------------
      ORIGINAL SITE
    --------------------------- */
    function getCountdown(targetDate){
      const now = Date.now();
      const d = targetDate - now;
      if (d <= 0) return "It‚Äôs today ‚ù§Ô∏è";
      const days = Math.floor(d/(1000*60*60*24));
      const hours = Math.floor((d/(1000*60*60))%24);
      const mins = Math.floor((d/(1000*60))%60);
      const secs = Math.floor((d/1000)%60);
      return `${days}d ${hours}h ${mins}m ${secs}s`;
    }

    function updateCountdowns(){
      const year = new Date().getFullYear();
      const feb25ThisYear = new Date(`February 25, ${year} 00:00:00`).getTime();
      const feb252027 = new Date("February 25, 2027 00:00:00").getTime();
      document.getElementById("valentineCountdown").textContent = getCountdown(feb25ThisYear);
      document.getElementById("anniversaryCountdown").textContent = getCountdown(feb252027);
    }
    setInterval(updateCountdowns, 1000); updateCountdowns();

    const slides = document.querySelectorAll(".slideshow img");
    let si = 0;
    setInterval(() => {
      slides[si].classList.remove("active");
      si = (si + 1) % slides.length;
      slides[si].classList.add("active");
    }, 3000);

    const music = document.getElementById("music");
    const musicBtn = document.getElementById("musicBtn");
    let musicOn = true;
    let musicBooted = false;

    function syncMusicUI(){
      musicBtn.textContent = musicOn ? "üîä Music: On" : "üîá Music: Off";
    }
    async function bootMusicOnce(){
      if (musicBooted) return;
      musicBooted = true;
      if (!musicOn) return;
      try { await music.play(); } catch {}
    }
    async function toggleMusic(){
      musicOn = !musicOn;
      if (!musicOn){
        music.pause();
        music.currentTime = 0;
      } else {
        try { await music.play(); } catch {}
      }
      syncMusicUI();
    }
    syncMusicUI();

    function yesClicked(){
      bootMusicOnce();
      const overlay = document.getElementById("loveOverlay");
      overlay.style.opacity = 1;

      const end = Date.now() + 5000;
      (function frame(){
        confetti({ particleCount: 6, spread: 70, origin: { y: 0.6 }});
        if (Date.now() < end) requestAnimationFrame(frame);
      })();

      setTimeout(() => overlay.style.opacity = 0, 2800);
    }
    function noClicked(){
      alert("Nice try üò§‚ù§Ô∏è");
    }
    window.addEventListener("pointerdown", bootMusicOnce, { once:true });

    /* ---------------------------
      GAME: City Edition
    --------------------------- */
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const highEl = document.getElementById("high");
    const spdEl = document.getElementById("spd");

    const HS_KEY = "valentine_city_run_high_v1";
    let high = Number(localStorage.getItem(HS_KEY) || 0);
    highEl.textContent = String(high);

    const GROUND = 246;
    const GRAVITY = 0.85;

    let running = true;
    let paused = false;

    let score = 0;
    let baseSpeed = 4.3;
    let speedRamp = 0.0019;

    let forwardHeld = false;

    const player = { x: 110, y: GROUND, vy: 0, onGround: true, w: 28, h: 44 };

    let hearts = [];
    let obstacles = [];
    let spawnTimer = 0;

    let skyScroll = 0;
    let nearScroll = 0;
    let farScroll = 0;

    const jumpBtn = document.getElementById("jumpBtn");
    const fwdBtn = document.getElementById("fwdBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    function togglePause(){
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? "‚ñ∂Ô∏è Resume" : "‚è∏ Pause";
    }

    function jump(){
      bootMusicOnce();
      if (!running || paused) return;
      if (player.onGround){
        player.vy = -14.2;
        player.onGround = false;
      }
    }
    function setForward(v){
      bootMusicOnce();
      forwardHeld = v;
    }

    jumpBtn.addEventListener("click", jump);
    fwdBtn.addEventListener("pointerdown", () => setForward(true));
    fwdBtn.addEventListener("pointerup", () => setForward(false));
    fwdBtn.addEventListener("pointercancel", () => setForward(false));
    fwdBtn.addEventListener("pointerleave", () => setForward(false));
    pauseBtn.addEventListener("click", togglePause);

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space"){ e.preventDefault(); jump(); }
      if (e.code === "ShiftLeft" || e.code === "ShiftRight"){ setForward(true); }
      if (e.code === "KeyP"){ togglePause(); }
      if (!running && (e.code === "Enter" || e.code === "Space")){ e.preventDefault(); restart(); }
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "ShiftLeft" || e.code === "ShiftRight"){ setForward(false); }
    });

    function rand(min,max){ return Math.random()*(max-min)+min; }

    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function circleRectOverlap(cx,cy,cr,r){
      const closestX = Math.max(r.x, Math.min(cx, r.x + r.w));
      const closestY = Math.max(r.y, Math.min(cy, r.y + r.h));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    function drawCityBackground(speed){
      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0, "#ffe2ea");
      g.addColorStop(1, "#ffffff");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // lights
      ctx.fillStyle = "rgba(255,80,120,0.22)";
      for (let i=0;i<30;i++){
        const x = (i*37 + skyScroll*0.35) % (canvas.width+60) - 30;
        const y = 20 + (i%6)*18;
        ctx.fillRect(x, y, 2, 2);
      }

      // far skyline
      farScroll = (farScroll + speed*0.25) % 200;
      ctx.fillStyle = "rgba(40,40,60,0.20)";
      for (let x=-220; x<canvas.width+220; x+=200){
        const bx = x - farScroll;
        const h = 70 + ((x/200)%3)*18;
        ctx.fillRect(bx, 165-h, 140, h);
        ctx.fillStyle = "rgba(255,90,130,0.15)";
        for (let wx=0; wx<120; wx+=18){
          for (let wy=0; wy<h-12; wy+=18){
            ctx.fillRect(bx+10+wx, 165-h+10+wy, 6, 6);
          }
        }
        ctx.fillStyle = "rgba(40,40,60,0.20)";
      }

      // near buildings
      nearScroll = (nearScroll + speed*0.6) % 160;
      ctx.fillStyle = "rgba(20,20,35,0.35)";
      for (let x=-200; x<canvas.width+200; x+=160){
        const bx = x - nearScroll;
        const h = 110 + ((x/160)%4)*18;
        ctx.fillRect(bx, 260-h, 120, h);
        ctx.fillStyle = "rgba(255,255,255,0.14)";
        for (let wx=0; wx<100; wx+=16){
          for (let wy=0; wy<h-12; wy+=16){
            ctx.fillRect(bx+10+wx, 260-h+10+wy, 6, 6);
          }
        }
        ctx.fillStyle = "rgba(20,20,35,0.35)";
      }

      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(0, GROUND + 44 - 2, canvas.width, 3);

      skyScroll = (skyScroll + speed) % 60;
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      for (let x=-40; x<canvas.width+40; x+=60){
        ctx.fillRect(x - skyScroll, GROUND + 44 + 12, 26, 3);
      }
    }

    // Pixel sprites inspired by your photos
    function drawPixelHer(x,y,scale=3){
      const p = scale;
      const layers = [
        {c:"#2b1b17", pts:[[3,0],[4,0],[5,0],[2,1],[3,1],[4,1],[5,1],[6,1],[2,2],[6,2],[1,3],[2,3],[6,3],[7,3]]}, // hair
        {c:"#111111", pts:[[2,3],[3,3],[4,3],[5,3],[6,3]]}, // glasses
        {c:"#f2c7a5", pts:[[3,2],[4,2],[5,2],[2,4],[3,4],[4,4],[5,4],[6,4]]}, // face
        {c:"#111111", pts:[[3,4],[5,4]]}, // eyes
        {c:"#101010", pts:[[2,6],[3,6],[4,6],[5,6],[6,6],[2,7],[3,7],[4,7],[5,7],[6,7]]}, // top
        {c:"#9aa0a6", pts:[[3,8],[4,8],[5,8],[3,9],[4,9],[5,9]]}, // pants
        {c:"#111111", pts:[[2,10],[3,10],[4,10],[5,10],[6,10]]} // shoes
      ];
      for (const L of layers){
        ctx.fillStyle = L.c;
        for (const [sx,sy] of L.pts){
          ctx.fillRect(x + sx*p, y + sy*p, p, p);
        }
      }
    }

    function drawPixelYou(x,y,scale=3){
      const p = scale;
      const layers = [
        {c:"#1a1a1a", pts:[[3,0],[4,0],[5,0],[2,1],[3,1],[4,1],[5,1],[6,1]]}, // hair
        {c:"#8a5a3c", pts:[[3,2],[4,2],[5,2],[2,3],[3,3],[4,3],[5,3],[6,3],[2,4],[3,4],[4,4],[5,4],[6,4]]}, // face
        {c:"#111111", pts:[[3,3],[5,3]]}, // eyes
        {c:"#4b2a2a", pts:[[2,6],[3,6],[4,6],[5,6],[6,6],[2,7],[3,7],[4,7],[5,7],[6,7]]}, // shirt/jacket
        {c:"#1f1f1f", pts:[[3,6],[5,6],[4,7]]}, // plaid accents
        {c:"#2a2a2a", pts:[[3,8],[4,8],[5,8],[3,9],[4,9],[5,9]]}, // pants
        {c:"#111111", pts:[[2,10],[3,10],[4,10],[5,10],[6,10]]} // shoes
      ];
      for (const L of layers){
        ctx.fillStyle = L.c;
        for (const [sx,sy] of L.pts){
          ctx.fillRect(x + sx*p, y + sy*p, p, p);
        }
      }
    }

    function drawHeart(h){
      ctx.font = "22px Arial";
      ctx.fillText("‚ù§Ô∏è", h.x - 10, h.y + 8);
    }

    function drawObstacle(o){
      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.fillRect(o.x+2, o.y+2, Math.max(2, o.w-8), 2);
    }

    function spawn(speed){
      spawnTimer -= 1;
      if (spawnTimer > 0) return;
      spawnTimer = Math.floor(rand(38, 74));

      const roll = Math.random();
      if (roll < 0.58){
        // obstacle with smaller hitbox
        const tall = Math.random() < 0.33;
        obstacles.push({
          x: canvas.width + 30,
          y: tall ? (GROUND + 44 - 34) : (GROUND + 44 - 20),
          w: tall ? 16 : 18,    // smaller
          h: tall ? 28 : 16     // smaller
        });
      } else {
        hearts.push({
          x: canvas.width + 30,
          y: rand(GROUND - 86, GROUND - 34),
          r: 12
        });
      }
    }

    function gameOver(){
      running = false;
      forwardHeld = false;
      paused = false;
      pauseBtn.textContent = "‚è∏ Pause";

      if (score > high){
        high = score;
        localStorage.setItem(HS_KEY, String(high));
        highEl.textContent = String(high);
      }

      document.getElementById("finalScore").textContent = String(score);
      document.getElementById("finalHigh").textContent = String(high);

      // draw mini sprites
      drawMiniSprites();

      document.getElementById("gameOver").style.display = "flex";
    }

    function drawMiniSprites(){
      const her = document.getElementById("miniHer").getContext("2d");
      const you = document.getElementById("miniYou").getContext("2d");

      her.clearRect(0,0,140,140);
      you.clearRect(0,0,140,140);

      // Backgrounds
      her.fillStyle = "rgba(255,255,255,0.95)";
      her.fillRect(0,0,140,140);
      you.fillStyle = "rgba(255,255,255,0.95)";
      you.fillRect(0,0,140,140);

      // Use the same sprite logic but draw on those contexts
      // We'll temporarily swap ctx reference by wrapping helpers:
      function drawTo(targetCtx, fn){
        const old = ctx;
        window.__oldCtx = old;
        // monkey-patch: reassign ctx variable via closure trick not possible here;
        // so we re-implement minimal draw for minis:
      }

      // Simple mini sprite rendering:
      function drawHerMini(target){
        const p = 6;
        const layers = [
          {c:"#2b1b17", pts:[[3,0],[4,0],[5,0],[2,1],[3,1],[4,1],[5,1],[6,1],[2,2],[6,2],[1,3],[2,3],[6,3],[7,3]]},
          {c:"#111111", pts:[[2,3],[3,3],[4,3],[5,3],[6,3]]},
          {c:"#f2c7a5", pts:[[3,2],[4,2],[5,2],[2,4],[3,4],[4,4],[5,4],[6,4]]},
          {c:"#111111", pts:[[3,4],[5,4]]},
          {c:"#101010", pts:[[2,6],[3,6],[4,6],[5,6],[6,6],[2,7],[3,7],[4,7],[5,7],[6,7]]},
          {c:"#9aa0a6", pts:[[3,8],[4,8],[5,8],[3,9],[4,9],[5,9]]},
          {c:"#111111", pts:[[2,10],[3,10],[4,10],[5,10],[6,10]]}
        ];
        for (const L of layers){
          target.fillStyle = L.c;
          for (const [sx,sy] of L.pts){
            target.fillRect( (sx*p)+40, (sy*p)+26, p, p );
          }
        }
      }

      function drawYouMini(target){
        const p = 6;
        const layers = [
          {c:"#1a1a1a", pts:[[3,0],[4,0],[5,0],[2,1],[3,1],[4,1],[5,1],[6,1]]},
          {c:"#8a5a3c", pts:[[3,2],[4,2],[5,2],[2,3],[3,3],[4,3],[5,3],[6,3],[2,4],[3,4],[4,4],[5,4],[6,4]]},
          {c:"#111111", pts:[[3,3],[5,3]]},
          {c:"#4b2a2a", pts:[[2,6],[3,6],[4,6],[5,6],[6,6],[2,7],[3,7],[4,7],[5,7],[6,7]]},
          {c:"#1f1f1f", pts:[[3,6],[5,6],[4,7]]},
          {c:"#2a2a2a", pts:[[3,8],[4,8],[5,8],[3,9],[4,9],[5,9]]},
          {c:"#111111", pts:[[2,10],[3,10],[4,10],[5,10],[6,10]]}
        ];
        for (const L of layers){
          target.fillStyle = L.c;
          for (const [sx,sy] of L.pts){
            target.fillRect( (sx*p)+40, (sy*p)+26, p, p );
          }
        }
      }

      drawHerMini(her);
      drawYouMini(you);
    }

    function restart(){
      document.getElementById("gameOver").style.display = "none";
      running = true;
      paused = false;
      score = 0;
      baseSpeed = 4.3;
      forwardHeld = false;
      hearts = [];
      obstacles = [];
      spawnTimer = 0;
      player.y = GROUND;
      player.vy = 0;
      player.onGround = true;
      pauseBtn.textContent = "‚è∏ Pause";
    }

    function step(){
      const speedMult = forwardHeld ? 1.55 : 1.0;
      const speed = baseSpeed * speedMult;

      if (running && !paused){
        baseSpeed += speedRamp;
        score += 1;
        scoreEl.textContent = String(score);
        spdEl.textContent = (speed / 4.3).toFixed(1);

        // physics
        player.vy += GRAVITY;
        player.y += player.vy;
        if (player.y >= GROUND){
          player.y = GROUND;
          player.vy = 0;
          player.onGround = true;
        }

        // spawn + move
        spawn(speed);

        for (const h of hearts) h.x -= speed;
        for (const o of obstacles) o.x -= speed;

        hearts = hearts.filter(h => h.x > -60);
        obstacles = obstacles.filter(o => o.x > -80);

        // collisions
        const pr = { x: player.x, y: player.y, w: player.w, h: player.h };

        // hearts
        for (let i = hearts.length - 1; i >= 0; i--){
          const h = hearts[i];
          if (circleRectOverlap(h.x, h.y, 12, pr)){
            hearts.splice(i, 1);
            score += 85;
          }
        }

        // obstacles: use smaller hit rect for the player too (fairer)
        const prFair = { x: player.x + 4, y: player.y + 6, w: player.w - 8, h: player.h - 10 };
        for (const o of obstacles){
          const oFair = { x: o.x + 2, y: o.y + 2, w: o.w - 4, h: o.h - 4 };
          if (rectsOverlap(prFair, oFair)){
            gameOver();
            break;
          }
        }
      }

      // draw
      drawCityBackground(running ? (paused ? 0 : (baseSpeed * (forwardHeld ? 1.55 : 1.0))) : 0);

      for (const h of hearts) drawHeart(h);
      for (const o of obstacles) drawObstacle(o);

      // draw player (her) sprite on the track
      // place sprite near player.x and player.y so it looks grounded
      drawPixelHer(player.x - 14, player.y - 40, 3);

      requestAnimationFrame(step);
    }

    step();
  </script>
</body>
</html>
